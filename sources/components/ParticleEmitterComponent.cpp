#include <noita/components/ParticleEmitterComponent.h>

void noita::components::ParticleEmitterComponent::parse(binary_io::any_istream &in, noita::components::ParticleEmitterComponent &out) {
    priv::read_integral(in, out.emitted_material_name);
    priv::read_integral(in, out.create_real_particles);
    priv::read_integral(in, out.emit_real_particles);
    priv::read_integral(in, out.emit_cosmetic_particles);
    priv::read_integral(in, out.cosmetic_force_create);
    priv::read_integral(in, out.render_back);
    priv::read_integral(in, out.render_ultrabright);
    priv::read_integral(in, out.collide_with_grid);
    priv::read_integral(in, out.collide_with_gas_and_fire);
    priv::read_integral(in, out.particle_single_width);
    priv::read_integral(in, out.emit_only_if_there_is_space);
    priv::read_integral(in, out.emitter_lifetime_frames);
    priv::read_integral(in, out.fire_cells_dont_ignite_damagemodel);
    priv::read_integral(in, out.color_is_based_on_pos);
    priv::read_integral(in, out.color);
    priv::read_integral(in, out.custom_alpha);
    types::vec2<float>::parse(in, out.offset);
    priv::read_integral(in, out.x_pos_offset_min);
    priv::read_integral(in, out.y_pos_offset_min);
    priv::read_integral(in, out.x_pos_offset_max);
    priv::read_integral(in, out.y_pos_offset_max);
    types::ValueRange<float>::parse(in, out.area_circle_radius);
    priv::read_integral(in, out.area_circle_sector_degrees);
    priv::read_integral(in, out.x_vel_min);
    priv::read_integral(in, out.x_vel_max);
    priv::read_integral(in, out.y_vel_min);
    priv::read_integral(in, out.y_vel_max);
    priv::read_integral(in, out.direction_random_deg);
    types::vec2<float>::parse(in, out.gravity);
    priv::read_integral(in, out.velocity_always_away_from_center);
    priv::read_integral(in, out.lifetime_min);
    priv::read_integral(in, out.lifetime_max);
    priv::read_integral(in, out.airflow_force);
    priv::read_integral(in, out.airflow_time);
    priv::read_integral(in, out.airflow_scale);
    priv::read_integral(in, out.friction);
    priv::read_integral(in, out.attractor_force);
    types::LensValue<int32_t>::parse(in, out.count_min);
    types::LensValue<int32_t>::parse(in, out.count_max);
    priv::read_integral(in, out.emission_interval_min_frames);
    priv::read_integral(in, out.emission_interval_max_frames);
    priv::read_integral(in, out.emission_chance);
    priv::read_integral(in, out.custom_style);
    priv::read_integral(in, out.delay_frames);
    priv::read_integral(in, out.is_emitting);
    priv::read_integral(in, out.use_material_inventory);
    priv::read_integral(in, out.is_trail);
    priv::read_integral(in, out.trail_gap);
    priv::read_integral(in, out.render_on_grid);
    priv::read_integral(in, out.fade_based_on_lifetime);
    priv::read_integral(in, out.draw_as_long);
    priv::read_integral(in, out.b2_force);
    priv::read_integral(in, out.set_magic_creation);
    priv::read_integral(in, out.image_animation_file);
    priv::read_integral(in, out.image_animation_colors_file);
    priv::read_integral(in, out.image_animation_speed);
    priv::read_integral(in, out.image_animation_loop);
    priv::read_integral(in, out.image_animation_phase);
    priv::read_integral(in, out.image_animation_emission_probability);
    priv::read_integral(in, out.image_animation_raytrace_from_center);
    priv::read_integral(in, out.image_animation_use_entity_rotation);
    priv::read_integral(in, out.ignore_transform_updated_msg);
}
